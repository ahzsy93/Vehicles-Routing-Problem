/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * NewJFrame.java
 *
 * Created on July 21, 2018, 8:30:44 AM
 */
package pkg;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;
import java.io.*;
import java.util.Locale;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.ButtonGroup;
import javax.swing.JFileChooser;
import javax.swing.JProgressBar;
import javax.swing.SwingUtilities;

/**
 *
 * @author Ali
 */

public class VrpVarForm extends javax.swing.JFrame {

    public static int p = 0;
    public static int g = 0;
    public static double c = 0;
    public static double m = 0;
    public static double s = 0;
    public static int n = 0;
    public static File file;
    public static File file1;
    public static boolean flag=false;
    public static boolean flag1=false;
    public static int val=0;

    /**
     * Creates new form NewJFrame
     */
    private void groupButton(){
        ButtonGroup bg = new ButtonGroup();
        bg.add(jRadioButton1);
        bg.add(jRadioButton2);
    }
    public VrpVarForm() {
        initComponents();
        groupButton();
    }
  
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        fileChooser = new javax.swing.JFileChooser();
        buttonGroup1 = new javax.swing.ButtonGroup();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        text = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        text1 = new javax.swing.JTextField();
        text2 = new javax.swing.JTextField();
        text3 = new javax.swing.JTextField();
        text5 = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        text4 = new javax.swing.JTextField();
        demand = new javax.swing.JButton();
        distance = new javax.swing.JButton();
        textdemand = new javax.swing.JTextField();
        textdistance = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jLabel8 = new javax.swing.JLabel();
        jRadioButton1 = new javax.swing.JRadioButton();
        jRadioButton2 = new javax.swing.JRadioButton();
        jPanel2 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel7 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setResizable(false);

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Input"));
        jPanel1.setName(""); // NOI18N

        jLabel1.setText("Population size           :");

        text.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                textActionPerformed(evt);
            }
        });

        jLabel2.setText("Generations                :");

        jLabel3.setText("Crossover probability :");

        jLabel4.setText("Mutation probability    :");

        jLabel5.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jLabel5.setText("عدد الحلول التي نريد إظهارها");

        text1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                text1ActionPerformed(evt);
            }
        });

        jLabel6.setText("Selection percent        :");

        demand.setText("Select demand table");
        demand.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                demandActionPerformed(evt);
            }
        });

        distance.setText("Select distance matrix");
        distance.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                distanceActionPerformed(evt);
            }
        });

        jButton1.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jButton1.setText("إظهار الحلول");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel8.setText("Select the Crossover you want to use :");

        jRadioButton1.setText("BCRC");
        jRadioButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButton1ActionPerformed(evt);
            }
        });

        jRadioButton2.setText("PMX");
        jRadioButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButton2ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel3)
                                    .addComponent(jLabel2)
                                    .addComponent(jLabel1)
                                    .addComponent(jLabel4))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(text3)
                                    .addComponent(text1)
                                    .addComponent(text)
                                    .addComponent(text2, javax.swing.GroupLayout.DEFAULT_SIZE, 78, Short.MAX_VALUE)))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel6)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(text4)))
                        .addGap(83, 83, 83)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(distance, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(textdemand)
                                .addComponent(demand, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(textdistance, javax.swing.GroupLayout.PREFERRED_SIZE, 137, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(10, 10, 10)
                                .addComponent(jRadioButton1)
                                .addGap(101, 101, 101)
                                .addComponent(jRadioButton2))
                            .addComponent(jLabel8))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jButton1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(text5, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabel5)))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(demand)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(textdemand, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(12, 12, 12)
                        .addComponent(distance)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(textdistance, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel8)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jRadioButton2)
                            .addComponent(jRadioButton1))
                        .addGap(88, 88, 88))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addGap(14, 14, 14)
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(jLabel2)
                                    .addComponent(text1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addComponent(text, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(12, 12, 12)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel3)
                            .addComponent(text2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel4)
                            .addComponent(text3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel6)
                            .addComponent(text4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(56, 56, 56)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jButton1)
                            .addComponent(jLabel5)
                            .addComponent(text5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("Output"));

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1)
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 165, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 20, Short.MAX_VALUE))
        );

        jLabel7.setForeground(new java.awt.Color(255, 0, 0));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(45, 45, 45)
                .addComponent(jLabel7)
                .addContainerGap(555, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 254, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel7)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void textActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_textActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_textActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        if (text.getText().isEmpty() || text1.getText().isEmpty() || text2.getText().isEmpty() || text3.getText().isEmpty() || text4.getText().isEmpty() || text5.getText().isEmpty() || textdemand.getText().isEmpty() || textdistance.getText().isEmpty()) {
            jLabel7.setText("ERROR: Please enter all the required details");
        }
        p = Integer.parseInt(text.getText());
        g = Integer.parseInt(text1.getText());
        c = Double.parseDouble(text2.getText());
        m = Double.parseDouble(text3.getText());
        s = Double.parseDouble(text4.getText());
        n = Integer.parseInt(text5.getText());
        flag=jRadioButton1.isSelected();
        flag1=jRadioButton2.isSelected();
        //VrpVar.proceed();
        VrpVar gr = new VrpVar();
        gr.proceed(gr);
        for (int i = 0; i < gr.generations; i++) {
            gr.runAlgorithm(gr,i);
        }
        
        String display = gr.saveAndDisplay(gr);
        
        
        jTextArea1.setText(display);
        
    }//GEN-LAST:event_jButton1ActionPerformed

    private void text1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_text1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_text1ActionPerformed

    private void demandActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_demandActionPerformed
        // TODO add your handling code here:
        int returnVal = fileChooser.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            file = fileChooser.getSelectedFile();
            textdemand.setText(file.getAbsolutePath());
    }//GEN-LAST:event_demandActionPerformed
    }
        private void distanceActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_distanceActionPerformed
            // TODO add your handling code here:
            int returnVal1 = fileChooser.showOpenDialog(this);
            if (returnVal1 == JFileChooser.APPROVE_OPTION) {
                file1 = fileChooser.getSelectedFile();
                textdistance.setText(file1.getAbsolutePath());
        }//GEN-LAST:event_distanceActionPerformed
        }
    private void jRadioButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButton1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jRadioButton1ActionPerformed

    private void jRadioButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButton2ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jRadioButton2ActionPerformed
    
    /**
     * @param args the command line arguments
     */
    public static void main() {
                /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Windows".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(bestroutes.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(bestroutes.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(bestroutes.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(bestroutes.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new VrpVarForm().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JButton demand;
    private javax.swing.JButton distance;
    private javax.swing.JFileChooser fileChooser;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JRadioButton jRadioButton1;
    private javax.swing.JRadioButton jRadioButton2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextField text;
    private javax.swing.JTextField text1;
    private javax.swing.JTextField text2;
    private javax.swing.JTextField text3;
    private javax.swing.JTextField text4;
    private javax.swing.JTextField text5;
    private javax.swing.JTextField textdemand;
    private javax.swing.JTextField textdistance;
    // End of variables declaration//GEN-END:variables
}
/*
 * a temporary class needed during pareto Ranking for storing multiple candidates
 * It contains an arraylist of candidates at a given rank.
 */

class RankedChromosome {

    ArrayList<Candidate> rank;
}

class VrpVar {

    int trucksRequired;
    int maxStops;
    static boolean flag;
    static boolean flag1;
    static int n = VrpVarForm.n;
    static File f = VrpVarForm.file;
    static File f1 = VrpVarForm.file1;
    static int val = VrpVarForm.val;
    int maxStores;
    int maxDemand;
    String routingMap;
    double distanceTravelled;
    double maxDistanceTravelled;
    double costIncurred;
    double efficiency;
    double profit;
    int deliveryTime;
    int maxTime;
    int userId;
    String password;
    int generations;
    int populationSize;
    static double mutationProbability = VrpVarForm.m;
    static double crossoverProbability = VrpVarForm.c;
    static double selectionPercent = VrpVarForm.s;
    ArrayList<Candidate> currentCandidates;
    ArrayList<Candidate> nextCandidates;
    ArrayList<Candidate> matingPool;
    ArrayList<Store> stores; // list of stores containing their names as string.
    double DCStoreMatrix[][]; // distance matrix including warehouse to store distance as last row.
    int storeSize; // number of stores including Data centre or Warehouse.
    ArrayList<RankedChromosome> rankArray; // ranked chromosomes are kept in this arraylist
    int SELECTIONSIZE;

    /*
     * Constructor to initialize all the arraylists
     */
    public VrpVar() {
        currentCandidates = new ArrayList<Candidate>();
        nextCandidates = new ArrayList<Candidate>();

        stores = new ArrayList<Store>();
        generations = VrpVarForm.g;
        flag=VrpVarForm.flag;
        flag1=VrpVarForm.flag1;

    }

    public void proceed(VrpVar g) {
        

        ReadData r = new ReadData(g);
        g.populationSize = VrpVarForm.p;
        g.SELECTIONSIZE = (int) (selectionPercent * g.populationSize);
        System.out.println("selection size: " + g.SELECTIONSIZE);
        try {
            FileReader fr = new FileReader(f.getAbsolutePath());
            r.readDemandTable(fr);
        } catch (IOException ex) {
            System.out.println("problem accessing file" + f.getAbsolutePath());
        }
        try {
            FileReader fr1 = new FileReader(f1.getAbsolutePath());
            r.readDistanceMatrix(fr1);
        } catch (IOException ex) {
            System.out.println("problem accessing file" + f1.getAbsolutePath());
        }

        g.greedyGeneratePopulation(100.0);
        //System.out.println("Current Candidates Population: ");
        //g.displayPopulation(g.currentCandidates);
        System.out.println("");
           }
    
    public void runAlgorithm(VrpVar g,int i) {
        
//            g.tournamentSelection();
            g.paretoRanking();

            g.tournamentRankSelection();

            if(flag1)
            g.crossoverPMX();
            if(flag)
            g.crossover();
            g.mutation(g.nextCandidates);

            g.currentCandidates = g.nextCandidates;
            System.out.println("Generation: " + (i + 1));
             
    }
    
    public String saveAndDisplay(VrpVar g) {
        String s = ""; 
        Collections.sort(g.currentCandidates);

        System.out.println("");
        for (int i = 1; i <= n; i++) {
            Candidate test = g.currentCandidates.get(i);
            s = s + "Candidate: " + i + "\nDistance travelled by trucks:" + test.fitness + "\nNumber of Trucks: " + test.routeTable.size() + "\nRank: " + test.rank + "\n";
        }
        g.writeToFile();

        
        return s;

    }

    public void generatePopulation() {
        for (int i = 0; i < populationSize; i++) {
            ArrayList<Integer> tmp = new ArrayList<Integer>();
            tmp.add(0);
            for (int j = 1; j < storeSize; j++) {
                tmp.add(j);
            }
            Random r = new Random();
            Candidate temp = new Candidate();
            int tmpncustomers = storeSize;

            temp.chromosome.add(tmp.get(0));
            tmp.remove(0);
            tmpncustomers--;

            for (int j = 1; j < storeSize; j++) {
                int tmpindex = r.nextInt(tmpncustomers);
                int tmpadd = tmp.get(tmpindex);
                tmp.remove(tmpindex);
                temp.chromosome.add(tmpadd);
                tmpncustomers--;
            }
            temp.routeTable = generateRoutes(temp);

            temp.fitness = evaluateFitnessCandidate(temp);
            currentCandidates.add(temp);
        }
    }

    private ArrayList<Route> generateRoutes(Candidate tmp) {
        ArrayList<Route> alroutesParent = new ArrayList<Route>();
        Route temp = new Route();
        temp.route.add(tmp.chromosome.get(0));
        int currentStops = 0;
        double currentDemand = 0;
        double currentDistance = 0;
        int length = tmp.chromosome.size();
        for (int i = 1; i < length; i++) {
            currentStops += 1;
            currentDemand += stores.get(tmp.chromosome.get(i)).demand;
            currentDistance += DCStoreMatrix[tmp.chromosome.get(i - 1)][tmp.chromosome.get(i)];
            if (currentDemand <= maxDemand && currentStops <= maxStops && currentDistance <= maxDistanceTravelled / 2) {
                temp.route.add(tmp.chromosome.get(i));
            } else {
                currentDemand = 0;
                currentStops = 0;
                currentDistance = 0;
                alroutesParent.add(temp);
                temp = new Route();
                temp.route.add(tmp.chromosome.get(0));
            }
        }
        alroutesParent.add(temp);

        return alroutesParent;
    }

    public void greedyGeneratePopulation(double euclidRadius) {
        for (int i = 0; i < populationSize; i++) {
            Candidate temp = new Candidate();

            ArrayList<Integer> tmp = new ArrayList<Integer>();
            tmp.add(0);
            for (int j = 1; j < storeSize; j++) {
                tmp.add(j);
            }

            temp.chromosome.add(0);
            tmp.remove(0);

            Random r = new Random();
            int rcustomer = r.nextInt(storeSize - 2) + 1;
            int custVal = tmp.get(rcustomer);
            tmp.remove(rcustomer);
            temp.chromosome.add(custVal);

            int tmpncustomers = storeSize;
            for (int j = 2; j < storeSize; j++) {
                // check the nearest neighbour to rcustomer in euclid radius specified
                int minindex = -1;
                double mindist = Double.MAX_VALUE;
                for (int k = 0; k < tmpncustomers - 2; k++) {
                    int l = tmp.get(k);
                    if (DCStoreMatrix[rcustomer][l] != 0 && DCStoreMatrix[rcustomer][l] < mindist && DCStoreMatrix[rcustomer][l] < euclidRadius) {
                        mindist = DCStoreMatrix[rcustomer][j];
                        minindex = k;
                    }
                }
                if (minindex != -1) {
                    custVal = tmp.get(minindex);
                    tmp.remove(minindex);
                    temp.chromosome.add(custVal);
                    rcustomer = minindex;
                } else {
                    rcustomer = r.nextInt(tmpncustomers);
                    custVal = tmp.get(rcustomer);
                    tmp.remove(rcustomer);
                    temp.chromosome.add(custVal);
                }
                tmpncustomers--;
            }
            temp.routeTable = generateRoutes(temp);
            temp.fitness = evaluateFitnessCandidate(temp);
            currentCandidates.add(temp);
        }
    }

    private double evaluateFitnessCandidate(Candidate tmp) {
        double tmpfitness = 0;
        int nroutes = tmp.routeTable.size();
        for (Route tmpRoute : tmp.routeTable) {
            evaluateFitnessRoute(tmpRoute);
            tmpfitness += tmpRoute.routeFitness;
        }
        return tmpfitness;
    }

    private void evaluateFitnessRoute(Route tmp) {
        double tmpfitness = 0;
        for (int i = 1; i < tmp.route.size(); i++) {
            int p = tmp.route.get(i - 1);
            int q = tmp.route.get(i);
            if (DCStoreMatrix[p][q] != 0) {
                tmpfitness += DCStoreMatrix[p][q];
            }
        }
        tmp.routeFitness = tmpfitness;
    }

    private void displayPopulation(ArrayList<Candidate> population) {
        for (Candidate tmp : population) {
            System.out.println(tmp.toString());
        }
    }

    private void displayRoutes(ArrayList<Route> alroutesParent) {
        // display routes
        for (Route tmp : alroutesParent) {
            for (int i : tmp.route) {
                System.out.print(i + " ");
            }
            System.out.println("");
        }
    }

    public void tournamentSelection() {
        matingPool = new ArrayList<Candidate>();
        ArrayList<Integer> populationSet = new ArrayList<Integer>();
        for (int i = 0; i < populationSize; i++) {
            populationSet.add(i);
        }

        int tmpncustomers = populationSize;
        for (int k = 0; k < SELECTIONSIZE; k++) {
            ArrayList<Integer> tournamentSet = new ArrayList<Integer>();
            ArrayList<Double> fitnessTournamentSet = new ArrayList<Double>();

            for (int i = 0; i < 4; i++) {
                Random r = new Random();
                int index = r.nextInt(tmpncustomers);
                int tmpnum = populationSet.get(index);
                populationSet.remove(index);
                tournamentSet.add(tmpnum);
                fitnessTournamentSet.add(currentCandidates.get(index).fitness);
                tmpncustomers--;
            }

            Random r = new Random();
            double gutter = r.nextDouble();

            if (gutter < 0.8) {
                double minFit = Double.MAX_VALUE;
                int minindex = -1;
                for (int i = 0; i < 4; i++) {
                    if (fitnessTournamentSet.get(i) < minFit) {
                        minFit = fitnessTournamentSet.get(i);
                        minindex = i;
                    }
                }
                Candidate tmp = currentCandidates.get(tournamentSet.get(minindex));
                matingPool.add(tmp);
                tournamentSet.remove(minindex);
            } else {
                int index = r.nextInt(4);
                Candidate tmp = currentCandidates.get(tournamentSet.get(index));
                matingPool.add(tmp);
                tournamentSet.remove(index);
            }

            populationSet.addAll(tournamentSet);
            tmpncustomers += 3;
        }
    }

    public void tournamentRankSelection() {
        matingPool = new ArrayList<Candidate>();
        for (RankedChromosome r : rankArray) {
            for (Candidate c : r.rank) {
                currentCandidates.add(c);
            }
        }
        ArrayList<Integer> populationSet = new ArrayList<Integer>();
        for (int i = 0; i < populationSize; i++) {
            populationSet.add(i);
        }

        int tmpncustomers = populationSize;
        for (int k = 0; k < SELECTIONSIZE / 2; k++) {
            ArrayList<Integer> tournamentSet = new ArrayList<Integer>();
            ArrayList<Integer> fitnessTournamentSet = new ArrayList<Integer>();

            for (int i = 0; i < 4; i++) {
                Random r = new Random();
                int index = r.nextInt(tmpncustomers);
                int tmpnum = populationSet.get(index);
                populationSet.remove(index);
                tournamentSet.add(tmpnum);
                fitnessTournamentSet.add(currentCandidates.get(index).rank);
                tmpncustomers--;
            }

            Random r = new Random();
            double gutter = r.nextDouble();

            if (gutter < 0.8) {
                double minFit = Double.MAX_VALUE;
                int minindex = -1;
                for (int i = 0; i < 4; i++) {
                    if (fitnessTournamentSet.get(i) < minFit) {
                        minFit = fitnessTournamentSet.get(i);
                        minindex = i;
                    }
                }
                Candidate tmp = currentCandidates.get(tournamentSet.get(minindex));
                matingPool.add(tmp);
                tournamentSet.remove(minindex);
            } else {
                int index = r.nextInt(4);
                Candidate tmp = currentCandidates.get(tournamentSet.get(index));
                matingPool.add(tmp);
                tournamentSet.remove(index);
            }

            populationSet.addAll(tournamentSet);
            tmpncustomers += 3;
        }
    }

    private Candidate inversion(Candidate candidate) {
        int chromosomeSize = candidate.chromosome.size();
        Random r = new Random();
        int windowSize = (r.nextDouble() > 0.5) ? 2 : 3;
        int pos = r.nextInt(chromosomeSize - 5) + 1;

        if (windowSize == 2) {
            int temp = candidate.chromosome.remove(pos);
            candidate.chromosome.add(pos, candidate.chromosome.remove(pos + 2));
            candidate.chromosome.add(pos + 2, temp);
        } else {
            int temp = candidate.chromosome.remove(pos);
            candidate.chromosome.add(pos, candidate.chromosome.remove(pos + 3));
            candidate.chromosome.add(pos + 3, temp);

            temp = candidate.chromosome.remove(pos + 1);
            candidate.chromosome.add(pos, candidate.chromosome.remove(pos + 2));
            candidate.chromosome.add(pos + 2, temp);
        }

        candidate.routeTable = generateRoutes(candidate);
        candidate.fitness = evaluateFitnessCandidate(candidate);

        return candidate;
    }


    private void mutation(ArrayList<Candidate> population) {
        Random r = new Random();
        int popSize = population.size();
        for (int i = 0; i < popSize; i++) {
            if (r.nextDouble() > VrpVar.mutationProbability) {
                Candidate temp = inversion(population.remove(i));
                population.add(temp);
            }
        }
    }


    public void paretoRanking() {
        rankArray = new ArrayList<RankedChromosome>();
        int currRank = 1;
        int N = populationSize;
        int m = populationSize;
        while (N != 0) {
            RankedChromosome temp = new RankedChromosome();
            temp.rank = new ArrayList<Candidate>();
            for (int i = 0; i < m; i++) {
                if (nonDominated(currentCandidates.get(i)) == true) {
                    currentCandidates.get(i).rank = currRank;
                }
            }
            for (int i = 0; i < m && i < N; i++) {
                if (currentCandidates.get(i).rank == currRank) {
                    temp.rank.add(currentCandidates.remove(i));
                    N--;
                    i--;
                }
            }
            rankArray.add(temp);
            currRank++;
            m = N;
        }
    }


    private boolean nonDominated(Candidate tmp) {
        for (Candidate temp : currentCandidates) {
            if (temp == tmp) {
                continue;
            }
            if ((temp.fitness <= tmp.fitness && temp.routeTable.size() < tmp.routeTable.size()) || (temp.fitness < tmp.fitness && temp.routeTable.size() <= tmp.routeTable.size())) {
                // tmp is dominated by temp
                return false;
            } else if (temp.fitness > tmp.fitness && temp.routeTable.size() > tmp.routeTable.size()) {
                // tmp is non-dominated
            } else {
                // not comparable
            }
        }
        return true;
    }


    private void bestRouteCrossover() {
        Random r = new Random();
        ArrayList<Integer> temp = new ArrayList<Integer>();
        int candidatesSize = matingPool.size();
        for (int i = 0; i < candidatesSize; i++) {
            temp.add(i);
        }

        int parent1Index = temp.remove(r.nextInt(candidatesSize));
        int parent2Index = temp.remove(r.nextInt(candidatesSize - 1));

        Candidate parent1 = matingPool.get(parent1Index);
        Candidate parent2 = matingPool.get(parent2Index);


        Candidate copyParent1 = copyCandidate(parent1);
        Candidate copyParent2 = copyCandidate(parent2);

        // Selecting key for Parent 1
        int tmp = r.nextInt(copyParent1.routeTable.size());
        Route keyParent1 = new Route();
        for (int i : copyParent1.routeTable.get(tmp).route) {
            keyParent1.route.add(i);
        }
        // Selecting key for Parent 2
        tmp = r.nextInt(copyParent2.routeTable.size());
        Route keyParent2 = new Route();
        for (int i : copyParent2.routeTable.get(tmp).route) {
            keyParent2.route.add(i);
        }
        // call method for removing keyParent elements from alroutesParent
        ArrayList<Route> newalroutesParent2 = removeSelectedElements(keyParent1, copyParent2.routeTable);
        ArrayList<Route> newalroutesParent1 = removeSelectedElements(keyParent2, copyParent1.routeTable);

        for (int i : keyParent1.route) {
            if (i == 0) {
                continue;
            }
            boolean flag = false;
            ArrayList<Candidate> tmpCandidates = new ArrayList<Candidate>();
            for (int k = 0; k < newalroutesParent2.size(); k++) {
                Route jroute = newalroutesParent2.get(k);
                for (int j = 1; j < jroute.route.size(); j++) {
                    // get a new copy of this candidate
                    Candidate tmpCopyCandidate = copyCandidate(copyParent2);
                    // insert the i node and check validity
                    tmpCopyCandidate.routeTable.get(k).route.add(j, i);
                    if (checkInsertionValidity(tmpCopyCandidate.routeTable.get(k))) {
                        flag = true;
                        tmpCopyCandidate.fitness = evaluateFitnessCandidate(tmpCopyCandidate);
                        tmpCandidates.add(tmpCopyCandidate);
                    }
                }
            }
            Collections.sort(tmpCandidates);
            if (tmpCandidates.size() != 0) {
                copyParent2 = tmpCandidates.get(0);
            }
        }
        for (int i : keyParent2.route) {
            if (i == 0) {
                continue;
            }
            boolean flag = false;
            ArrayList<Candidate> tmpCandidates = new ArrayList<Candidate>();
            for (int k = 0; k < newalroutesParent1.size(); k++) {
                //System.out.println("Route k: " + k);
                Route jroute = newalroutesParent1.get(k);
                for (int j = 1; j < jroute.route.size(); j++) {
                    // get a new copy of this candidate
                    Candidate tmpCopyCandidate = copyCandidate(copyParent1);
                    // insert the i node and check validity
                    tmpCopyCandidate.routeTable.get(k).route.add(j, i);
                    if (checkInsertionValidity(tmpCopyCandidate.routeTable.get(k))) {
                        flag = true;
                        tmpCopyCandidate.fitness = evaluateFitnessCandidate(tmpCopyCandidate);
                        tmpCandidates.add(tmpCopyCandidate);
                    }
                }
            }
            if (flag == false) {
                //System.out.println("Hello");
                copyParent1.routeTable.get(copyParent1.routeTable.size() - 1).route.add(i);
                copyParent1.fitness = evaluateFitnessCandidate(copyParent1);
                tmpCandidates.add(copyParent1);
            }
            Collections.sort(tmpCandidates);
            copyParent1 = tmpCandidates.get(0);
        }
        nextCandidates.add(copyParent1);
        nextCandidates.add(copyParent2);
    }

    private void crossover() {
        nextCandidates = new ArrayList<Candidate>();
        int crossoverPopulationSize = matingPool.size();
        for (int i = 0; i < crossoverPopulationSize; i++) {
            bestRouteCrossover();
        }
        Collections.sort(matingPool);
        for(int i=0;i<matingPool.size();i++) {
            nextCandidates.add(matingPool.get(i));
        }
    }

    private void crossoverPMX() {
        Collections.sort(matingPool);
        Random r = new Random();
        nextCandidates = new ArrayList<Candidate>();
        for (int k = 0; k < populationSize / 2; k++) {

            double probability = r.nextDouble();
            if (probability < crossoverProbability) {

                int candidateSize = matingPool.size();

                int parent1Index = r.nextInt(candidateSize);
                int parent2Index = r.nextInt(candidateSize);
                while (parent1Index == parent2Index) {
                    parent2Index = r.nextInt(candidateSize);
                }

                Candidate parent1 = matingPool.get(parent1Index);
                Candidate parent2 = matingPool.get(parent2Index);

                Candidate copyParent1 = copyCandidate(parent1);
                Candidate copyParent2 = copyCandidate(parent2);

                int chromosomeSize = matingPool.get(0).chromosome.size();
                int cuttingPoint1 = r.nextInt(chromosomeSize);
                int cuttingPoint2 = r.nextInt(chromosomeSize);

                while (cuttingPoint1 == cuttingPoint2) {
                    cuttingPoint2 = r.nextInt(chromosomeSize);
                }

                if (cuttingPoint1 > cuttingPoint2) {
                    int swap;
                    swap = cuttingPoint1;
                    cuttingPoint1 = cuttingPoint2;
                    cuttingPoint2 = swap;
                }

                ArrayList<Integer> replacement1 = new ArrayList<Integer>();
                ArrayList<Integer> replacement2 = new ArrayList<Integer>();

                for (int i = 0; i < chromosomeSize; i++) {
                    replacement1.add(-1);
                    replacement2.add(-1);
                }

                ArrayList<Integer> offspring1Vector = new ArrayList<Integer>();
                ArrayList<Integer> offspring2Vector = new ArrayList<Integer>();
                for (int i = 0; i < chromosomeSize; i++) {
                    offspring1Vector.add(i);
                    offspring2Vector.add(i);
                }

                for (int i = cuttingPoint1; i <= cuttingPoint2; i++) {
                    offspring1Vector.remove(i);
                    offspring1Vector.add(i, copyParent2.chromosome.get(i));
                    offspring2Vector.remove(i);
                    offspring2Vector.add(i, copyParent1.chromosome.get(i));

                    int index = copyParent2.chromosome.get(i);
                    replacement1.remove(index);
                    replacement1.add(index, copyParent1.chromosome.get(i));
                    index = copyParent1.chromosome.get(i);
                    replacement2.remove(index);
                    replacement2.add(index, copyParent2.chromosome.get(i));
                }

                for (int i = 0; i < chromosomeSize; i++) {
                    if ((i >= cuttingPoint1) && (i <= cuttingPoint2)) {
                        continue;
                    }

                    int n1 = copyParent1.chromosome.get(i);
                    int m1 = replacement1.get(n1);

                    int n2 = copyParent2.chromosome.get(i);
                    int m2 = replacement2.get(n2);

                    while (m1 != -1) {
                        n1 = m1;
                        m1 = replacement1.get(m1);
                    } // while


                    while (m2 != -1) {
                        n2 = m2;
                        m2 = replacement2.get(m2);
                    } // while

                    Integer element = new Integer(offspring1Vector.get(i));
                    offspring1Vector.remove(element);
                    offspring1Vector.add(i, n1);
                    element = new Integer(offspring2Vector.get(i));
                    offspring2Vector.remove(element);
                    offspring2Vector.add(i, n2);
                }

                Candidate offspring1 = new Candidate();
                Candidate offspring2 = new Candidate();
                offspring1.chromosome = offspring1Vector;
                offspring2.chromosome = offspring2Vector;

                offspring1.routeTable = generateRoutes(offspring1);
                offspring2.routeTable = generateRoutes(offspring2);
                offspring1.fitness = evaluateFitnessCandidate(offspring1);
                offspring2.fitness = evaluateFitnessCandidate(offspring2);

                nextCandidates.add(offspring1);
                nextCandidates.add(offspring2);
            } else {
                nextCandidates.add(matingPool.get(k % 10));
            }
        }

        int tmpSize = populationSize - nextCandidates.size();
        for (int i = 0; i < tmpSize; i++) {
            nextCandidates.add(matingPool.get(i));
        }
    }

    private int checkStoresAll(ArrayList<Route> tmp) {
        int result = 0;
        for (Route r : tmp) {
            result += r.route.size() - 1;
        }
        return result + 1;
    }

    private ArrayList<Route> removeSelectedElements(Route temp, ArrayList<Route> alrouteParent) {
        ArrayList<Route> temporary = new ArrayList<Route>();
        for (Route tmp : alrouteParent) {
            for (int i : temp.route) {
                if (i == 0) {
                    continue;
                }
                tmp.route.remove(new Integer(i));
            }
            if (!tmp.route.isEmpty()) {
                temporary.add(tmp);
            }
        }
        return temporary;
    }

    private Candidate copyCandidate(Candidate tmp) {
        Candidate tmpCopy = new Candidate();
        tmpCopy.fitness = tmp.fitness;
        tmpCopy.rank = tmp.rank;
        for (int i : tmp.chromosome) {
            tmpCopy.chromosome.add(new Integer(i));
        }
        for (Route tmpRoute : tmp.routeTable) {
            Route copyRoute = new Route();
            for (int i : tmpRoute.route) {
                copyRoute.route.add(new Integer(i));
            }
            tmpCopy.routeTable.add(copyRoute);
        }

        return tmpCopy;
    }

    private boolean checkInsertionValidity(Route tmp) {
        if (tmp.route.size() > maxStops) {
            return false;
        }

        double currentDistance = DCStoreMatrix[0][tmp.route.get(0)];
        int currentDemand = stores.get(tmp.route.get(0)).demand;
        for (int i = 1; i < tmp.route.size(); i++) {
            currentDistance += DCStoreMatrix[tmp.route.get(i - 1)][tmp.route.get(i)];
            currentDemand += stores.get(tmp.route.get(i)).demand;
        }

        if (currentDemand > maxDemand || currentDistance > maxDistanceTravelled / 2) {
            return false;
        }
        return true;
    }

    
    private void writeToFile() {
        try {
            
            FileInputStream finbest = new FileInputStream("bestsolutions.phy");
            ObjectInputStream oisbest = new ObjectInputStream(finbest);
            
            FileOutputStream fout = new FileOutputStream("solutions.phy");
            FileOutputStream foutstores = new FileOutputStream("stores.phy");
            ObjectOutputStream oos = new ObjectOutputStream(fout);
            ObjectOutputStream oosstores = new ObjectOutputStream(foutstores);
            
            ArrayList<Candidate> bestCandidates = new ArrayList<>();
            
            int i=0;
            for (Candidate c : currentCandidates) {
                i++;
                oos.writeObject(c);
                bestCandidates.add(c);
                if (i == 10) {
                    break;
                } 
            }
            
            for (Store s : stores) {
                oosstores.writeObject(s);
            }
            
            // Read Best Candidates
            int j=0;
            while(true) {
                j++;
                Candidate tmpBestCandidate = (Candidate) oisbest.readObject();
                bestCandidates.add(tmpBestCandidate);
                if(j==10) {
                    break;
                }
            }
            
            Collections.sort(bestCandidates);
            
            FileOutputStream foutbest = new FileOutputStream("bestsolutions.phy");
            ObjectOutputStream oosbest = new ObjectOutputStream(foutbest);
            int k=0;
            for (Candidate c : bestCandidates) {
                k++;
                oosbest.writeObject(c);
                if (k == 10) {
                    break;
                } 
            }
            
        } catch (IOException | ClassNotFoundException e) {
        }
    }
    
    
    // Methods to generate a string for saving the result in pdf.
   

}


// Class Adjust Factors for setting the variables of genetic operations
class AdjustFactors {
    /*
     * Used to set the Genetic operator values as fetched from the user.
     */
    VrpVar g;
    
    int selectionPercent;
    double crossoverProbability;
    double mutationProbability;
    
    AdjustFactors(int selectionPercent, double crossoverProbibility, double mutationProbability) {
        
        g = new VrpVar();
 
        this.selectionPercent = selectionPercent;
        this.crossoverProbability = crossoverProbibility;
        this.mutationProbability = mutationProbability;
    }
    
}
